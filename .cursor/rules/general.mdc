---
description: 
globs: 
alwaysApply: true
---
# General Project Guidelines

## Summary for Agent Requests

Core project overview, principles, and operational guidelines covering the project's purpose, underlying technologies, parameter resolution patterns, workflow modes (Normal and Development), and the standard interaction workflow for implementing features and changes.

## 1. Project Overview

This project implements a specialized **MCP (Model Context Protocol) Server** ([MCP Introduction](mdc:https:/modelcontextprotocol.io/introduction)) designed to streamline GitHub project management workflows. It is built using the official MCP Python SDK ([`modelcontextprotocol/python-sdk`](mdc:https:/github.com/modelcontextprotocol/python-sdk)).

**Inspiration and Motivation:**
The server's functionality is heavily inspired by the official GitHub MCP Server ([`github/github-mcp-server`](mdc:https:/github.com/github/github-mcp-server)). However, this project was created specifically to address the lack of integration with the GitHub Projects API ([`gh project` CLI Manual](mdc:https:/cli.github.com/manual/gh_project)) in the official server.

**Functionality:**
This server aims to provide comprehensive GitHub interaction capabilities, including:
*   Standard GitHub operations (managing issues, pull requests, branches - similar to the official server).
*   **Extended functionality for GitHub Projects**, enabling the creation, retrieval, listing, and modification of project items and fields.

**Goal:**
The primary goal is to function as an intelligent **GitHub Project Manager**. By interpreting user requests, the server aims to automate the process of creating related issues, managing tasks, updating project boards, and opening pull requests, allowing developers to focus more on coding.

**Core Philosophy:**
*   **Convention over Configuration:** The server prioritizes sensible defaults for common parameters (e.g., default priority for tasks). Users can configure these defaults to minimize the input required for routine actions.
*   **Intelligent Parameter Handling:** The server attempts to extract all necessary information from the user's input first. If required parameters are missing, it consults the configured defaults. Only if essential parameters remain unresolved should the interacting MCP client prompt the user for clarification. This balances automation with user control, acknowledging the collaborative role between the MCP server (providing tools and defaults) and the MCP client (managing user interaction and final parameter gathering).

## 2. Core Principles & Technologies
-   **Language:** Python 3.11+
-   **Package Management:** Poetry (`uv` preferred if available via Poetry)
-   **Code Style:** Ruff for formatting and linting. Adhere to standard Python conventions (PEP 8). (See `python-standards.mdc` for details)
-   **Core Principle:** Prioritize clean, readable, maintainable, and well-tested code.

## 3. Parameter Resolution Pattern (`resolve_param` & `TOOL_PARAM_CONFIG`)

This project uses a specific pattern for resolving optional tool parameters, allowing values to come from runtime arguments, environment variables, or defaults defined in `src/gh_project_manager_mcp/config.py`.

-   **Mechanism:** Uses the `utils.gh_utils.resolve_param` function.
-   **Configuration:** Relies on the `TOOL_PARAM_CONFIG` dictionary defined in `src/gh_project_manager_mcp/config.py`.
-   **Mandatory Update:** When implementing/modifying a tool function that uses `resolve_param` for an optional parameter, the corresponding entry in `TOOL_PARAM_CONFIG` MUST be added or updated.
-   **Type Specification:** EVERY parameter definition in `TOOL_PARAM_CONFIG` MUST include a `'type'` key (`'str'`, `'int'`, `'list'`, `'bool'`). Use `'type': 'str'` if no specific handling is needed but the parameter exists in the config.
-   **`gh` CLI Verification:** Cross-reference `gh` command documentation to ensure parameter types specified in `TOOL_PARAM_CONFIG` match the expected CLI behavior, as the resolved value will eventually be passed to the `gh` command.

## 4. Operational & Workflow Guidelines

### 4.1. Terminal Commands

-   **Automatic Execution:** Propose and then automatically execute necessary terminal commands (dependency installation, server execution, etc.) unless specifically instructed otherwise. Do not wait for manual execution.
-   **Output Analysis:** After EVERY terminal command execution, carefully analyze the *entire* stdout, stderr, and exit code. Report any errors, warnings, or unexpected output before proceeding. Do not assume success based solely on a zero exit code.
-   **Retry Transient Errors:** If a command (especially network-dependent ones like `docker build`, `poetry install`) fails with a clearly transient network/DNS error (e.g., 'Could not resolve host', 'Temporary failure in name resolution', 'lookup ... no such host'), announce a retry, wait ~5 seconds, and retry **up to two times** (3 attempts total). Report persistent errors after retries.

### 4.2 Normal Mode Workflow (Default)

-   **Activation:** This is the default operational mode. It is active unless Development Mode is triggered.
-   **Behavior:**
    -   Follow the **Standard Interaction Workflow (Section 5)**.
    -   **Planning:** Always present a plan (or task list for non-trivial tasks) before proposing code.
    -   **Implementation/Proposal:**
        -   **Propose** all code changes, file creations, or deletions using markdown code blocks.
        -   **Await explicit user approval** before using any tools to implement the proposed changes.
    -   **Verification & Iteration:**
        -   Report verification results (lint, test, command outputs).
        -   If verification fails or issues arise, analyze the cause, **propose a fix**, and **await explicit user approval** before implementing the fix.
-   **Goal:** Prioritize user oversight and explicit confirmation before any modifications to the codebase or project state.

### 4.3 Development Mode Workflow

-   **Activation:** Triggered by any user command containing the phrase "development mode" (e.g., "go development mode", "switch to development mode", "code in development mode"). Remains active only for the *currently active* user request.
-   **Behavior:**
    -   Follow the **Standard Interaction Workflow (Section 5)**.
    -   Implement requested features (code creation/edits/refactors) corresponding unit tests (`pytest`), and run all tests (`make test`) after changes **without seeking explicit user approval for each code modification step**.
    -   Autonomously fix task-related bugs, test failures, or linter errors identified during verification.
    -   Apply the retry logic for transient command errors (see 4.1).
    -   Cycle implement-test-fix until the request is complete or an unresolvable blocker occurs.
    -   Report progress, significant actions, and final results concisely.
-   **Deactivation:** Automatically reverts to Normal Mode upon completion of the current task, or explicitly by user command "LEAVE DEVELOPMENT MODE".
-   **Scope:** Applies only to the *currently active* user request. Standard approval rules (Normal Mode) apply outside this scope.


### 4.4. Rule Creation ("Rulenize")

-   **Trigger:** User command "Rulenize" on a new line after a clarification/guideline.
-   **Action:** Analyze preceding conversation, formulate a concise rule, determine the best location in `.cursor/rules/*.mdc`, propose the rule and location, iterate based on feedback, and implement upon approval.

## 5. Standard Interaction Workflow (Code & Features)

**Rule:** This workflow **MUST** be followed for **all interactions** involving code creation, modification, refactoring, or feature implementation, unless the request is a trivial query (e.g., simple questions, link lookups) that does not alter code or project state. The specific behavior for implementation and iteration steps depends on the active operational mode (See Section 4.2 for Normal Mode, Section 4.3 for Development Mode).

**Workflow Steps:**

1.  **Analyze & Plan:**
    *   Thoroughly understand the request's intent and context.
    *   For non-trivial tasks (new features, complex fixes, multi-step changes), create or update a task list file in `./tasks/` adhering to `@task-list.mdc`, including an initial Implementation Plan. Present the task list for approval if newly created.
    *   For simpler changes, formulate a clear step-by-step internal plan.
    *   Identify potentially affected files, modules, and configurations.

2.  **Research & Consult Guidelines:**
    *   Proactively use available tools (search, read file, list dir) to gather necessary context from the codebase, project rules (`.cursor/rules/*.mdc`), dependencies, and relevant documentation (`gh` manuals, etc.).
    *   Verify assumptions and resolve ambiguities using gathered information. Make reasoned decisions based on project conventions or dominant patterns if necessary, documenting the rationale. Seek clarification only if blocked.
    *   Consult specific guidelines relevant to the task (e.g., `@architecture.mdc`, `@python-standards.mdc`, `@error-handling.mdc`, `@testing.mdc`, Parameter Resolution Pattern in this file).

3.  **Implement / Propose:**
    *   Execute this step according to the behavior defined for the **currently active operational mode** (Normal Mode: Section 4.2, Development Mode: Section 4.3).
    *   *(Normal Mode Summary: Propose changes, await approval, implement approved changes.)*
    *   *(Development Mode Summary: Implement changes directly.)*

4.  **Verify:**
    *   After implementing changes, perform verification:
        *   Run linters and formatters (`make format lint`).
        *   Write and run relevant unit tests (`make test` or more specific targets like `make test-tool tool=...`). Ensure tests pass and cover relevant logic according to `@testing.mdc`.
        *   Analyze command outputs (`stdout`, `stderr`, exit codes) for any errors or warnings.

5.  **Iterate / Fix:**
    *   Execute this step according to the behavior defined for the **currently active operational mode** (Normal Mode: Section 4.2, Development Mode: Section 4.3).
    *   *(Normal Mode Summary: Report results, propose fixes, await approval for fixes.)*
    *   *(Development Mode Summary: Autonomously attempt fixes and loop Verify -> Fix.)*

6.  **Update & Report:**
    *   If a task list was used, update it by marking completed items (`[x]`).
    *   Provide a concise summary report of actions taken, verification results, rationale for significant decisions (especially ambiguity resolution), and the final status (completed, blocked, etc.).

*(Renumber subsequent sections in `@general.mdc` as needed)*
